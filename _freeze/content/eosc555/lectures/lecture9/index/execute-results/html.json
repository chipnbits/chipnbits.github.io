{
  "hash": "43f2dd2f29a584afe82a165b482ea4f4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Lecture 9\"\nsubtitle: \"Machine Learning and Neural Networks\"\ndate: 2024-11-05\nauthor: \"Simon Ghyselincks\"\ndescription: >-\n    Neural networks have revolutionized the field of machine learning, but how exactly do they work? In this lecture, we will explore the basic structure of these models from a mathematical perspective. We will also discuss the role of regularization and priors in solving inverse problems.\ncategories:\n  - Machine Learning\n  - Neural Networks\n  \ndraft: false\n\neditor: \n  render-on-save: false\n\nfilters:\n  - pseudocode\n  - diagram\n\nbibliography: references.bib\nbiblatexoptions: \"style=numeric,sorting=nyt\"  # Uses numbered style and sorts by name-year-title\nbiblio-style: numeric-comp  # A numeric style in biblatex, similar to IEEE, with compressed citation ranges\n\npseudocode:\n  caption-prefix: \"Algorithm\"\n  reference-prefix: \"Algorithm\"\n  caption-number: true\n---\n\n::: {.hidden}\n$$\n\\def\\argmin{\\operatorname*{argmin}}\n\\def\\bmat#1{\\begin{bmatrix}#1\\end{bmatrix}}\n\\def\\Diag{\\mathbf{Diag}}\n\\def\\ip#1{\\langle #1 \\rangle}\n\n\\def\\maximize#1{\\displaystyle\\maxim_{#1}}\n\n\\def\\minimize#1{\\displaystyle\\minim_{#1}}\n\\def\\norm#1{\\|#1\\|}\n\\def\\proj{\\mathbf{proj}}\n\\def\\R{\\mathbb R}\n\\def\\Re{\\mathbb R}\n\\def\\Rn{\\R^n}\n\\def\\rank{\\mathbf{rank}}\n\\def\\range{{\\mathbf{range}}}\n\\def\\span{{\\mathbf{span}}}\n\\def\\textt#1{\\quad\\text{#1}\\quad}\n\\def\\trace{\\mathbf{trace}}\n\\def\\bf#1{\\mathbf{#1}}\n$$\n:::\n\n\n\n## Motivation\n\nIn the previous lecture, we viewed different priors or regularizers and how they can be used to help solve inverse problems. A regularizer for least squares in the most general sense is given as:\n\n$$ \\min_{u} \\left\\{ \\frac{1}{2} \\left\\| Au(x) - b \\right\\|_2^2 + \\lambda R(u) \\right\\} $$\n\nwhere $u(x)$ is a distribution of the unknowns over the domain $x$, $A$ is the forward operator, $b$ is the data, and $R(u)$ is the regularizer. A neural network can be used as a universal approximator for the function $R: \\mathbb{R}^n \\rightarrow \\mathbb{R}$, where $n$ is the number of unknowns, or values of $u$.\n\n## Neural Networks\n\n### A Basic Neural Network: Single-Layer Perceptron (SLP)\n\nA basic neural network will have parameters $\\theta$ that can be trained or learned, along with the input, $u$.\n\n$$y = R(u; \\theta) = w^T \\sigma(Wu+a), \\quad \\theta := \\{w, W, a\\}$$\n\nThe function $R$ in this case is a function defined for fixed $\\theta$. The term $\\sigma$ is a non-linear activation function, of which there are many choices. \n\n- **$u$**: Input vector to the neural network.\n  \n- **$y$**: Output of the neural network, parameterized by $\\theta$, representing the learned function.\n\n- **$\\theta := \\{w, W, a\\}$**: Set of trainable parameters in the network, where:\n  - **$w$**: Weight vector for the output layer\n  - **$W$**: Weights matrix for the hidden layer\n  - **$a$**: Bias vector added to the hidden layer\n\n- **$\\sigma$**: Non-linear activation function applied element-wise to the affine transformation $Wu + a$. \n\nSo a single layer neural network can be seen as the affine transformation of the vector $u$ followed by a non-linear activation function and a weighting metric for the resultant vector.\n\nThis can be used as an approximator for the true regularizer $R(u) \\approx R_T(u)$ in the inverse problem.\n\nSuppose that we have a known set of mappings $u_i \\rightarrow y_i$, where $i = 1, \\ldots, N$. For example we might have some information about the regularizer $R(u)$ for a set of $u$ values. One possible technique is to train an SLP to approximate the true regularizer $R_T(u)$.\n\nThe function $y = R(u; \\theta)$ returns a scalar, taking its transpose will not change the output:\n\n$$y = w^T \\sigma(Wu+a) = \\sigma(u^TW + a)w$$\n\nThen using the squared loss function, we can define the loss function as:\n\n$$\\mathcal{L}(\\theta) = \\frac{1}{2} \\sum_{i=1}^N \\left \\| \\sigma(u^TW + a)w - y_i \\right \\|^2$$\n\nThe summation is reorganized to get rid of the summation term where $U$ is a matrix with the $u_i^T$ as the columns, A is a matrix with $a$ as the columns, and $y$ is the vector of $y_i$ values.\n\n$$\\mathcal{L}(\\theta) = \\frac{1}{2} \\left \\| \\sigma(U^TW + A)w - y \\right \\|^2$$\n\nFor simplicity of this analysis, we can assume without loss of generality for the problem at hand that $A = 0$ and $\\sigma$ is the identity operator. Then:\n\n$$\\hat\\theta = \\min_{\\theta} \\mathcal{L}(\\theta) = \\min_{\\hat w} \\frac{1}{2} \\left \\| U^T\\hat w - y \\right \\|^2.$$\n\nwhere $\\hat w = Ww$.\n\n### Non-linearity Analysis\n\nThis least squares problem will generally be ill-posed when the activation function is not present (the case with identity activation). $N>d$ means that there are more equations than there are unknowns, because $\\hat w$ is of dimension $d$, so there could be infinite solutions.\n\n$$\\hat{\\theta} = \\min_{\\theta} \\frac{1}{2} \\left\\|\n\\underbrace{\n\\begin{bmatrix}\n\\ & \\ & \\ \\\\\n\\ & U^T & \\ \\\\\n\\ & \\ & \\ \\\\\n\\end{bmatrix}\n}_{N \\times d}\n\\cdot\n\\underbrace{\n\\begin{bmatrix}\n\\ & \\ & \\ \\\\\n\\ & W & \\ \\\\\n\\ & \\ & \\ \\\\\n\\end{bmatrix}\n}_{N \\times k}\n- y \\right\\|^2\n$$\n\n\n\n**Idea 1:**\n\nIf we can increase the rank of the $Z = U^TW$ matrix, then perhaps it is possible to solve the problem batter. We select for there to be a larger weights matrix $W$ that is $N \\times m$ where $m > d$. In the resulting $z = U^TW$ matrix, the rank will still be $\\text{rank}(Z) \\le d$.\n\n**Idea 2:**\n\nUse a non-linear activation function $\\sigma$ that operates element-wise on the matrix $Z = U^TW$ to increase the rank of the matrix so that $\\text{rank}(\\sigma(Z)) = \\min (N,m)$.\n\nIn practice the exact activation function is not important. It may be the case that $\\text{rank}(\\sigma(Z)) = 3$ for example, but applying the activation function will increase the rank to the minimum dimension size of the weights matrix $W$. This can give a unique solution the least squares problem.\n\n$$\n\\hat{\\theta} = \\min_{\\theta} \\frac{1}{2} \\left\\|\n\\sigma \\left( \\underbrace{\n\\begin{bmatrix} \n\\ & \\ & \\ \\\\\n\\ & U^T & \\ \\\\\n\\ & \\ & \\ \\\\\n\\end{bmatrix}\n}_{N \\times d}\n\\cdot\n\\underbrace{\n\\begin{bmatrix}\n\\ & \\ & \\ & \\ & \\cdots & \\ \\\\\n\\ & W & \\ & \\ & \\ & \\ \\\\\n\\ & \\ & \\ & \\ & \\ & \\ \\\\\n\\end{bmatrix}\n}_{N \\times m}\n\\right ) w\n-\ny \\right\\|^2\n$$\n\n#### Non-linear Example\n\nTo illustrate the rank recovery property and the improvement for finding a unique solution to the least squares problem, we consider a simple example below.\n\n::: {#fig-nonlinear-rank-recovery .cell fig-width='3' layout-ncol='2' execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom numpy.linalg import lstsq, matrix_rank\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Parameters\nN = 10  # Number of samples\nd = 5   # Dimension of input u\nm = 10  # Increased dimension for W\n\n# Generate random input data U (d x N)\nU = np.random.randn(d, N)\n\n# True weight matrix W_true (d x d)\nW_true = np.random.randn(d, d)\nw_true = np.random.randn(d)\n\n# Generate nonlinear output to test with\ny_linear = (np.cos(U.T @ W_true)) @ w_true\n\n# Initialize random model weight matrix W (d x m)\nW = np.random.randn(d, m)\nZ = U.T @ W\nrank_Z = matrix_rank(Z)\n\nsigma = np.sin\nZ_nonlinear = sigma(Z)\nrank_Z_nl = matrix_rank(Z_nonlinear)\n\nw_linear, residuals_linear, _, _ = lstsq(Z, y_linear, rcond=None)\nw_nonlinear, residuals_nl, _, _ = lstsq(Z_nonlinear, y_linear, rcond=None)\n\n# Check reconstruction error for each case\nerror_linear = np.linalg.norm(Z @ w_linear - y_linear)\nerror_nonlinear = np.linalg.norm(Z_nonlinear @ w_nonlinear - y_linear)\n\n# Comparison of Reconstruction Errors\nlabels = ['Linear Least Squares', 'Non-linear Least Squares']\nerrors = [error_linear, error_nonlinear]\n\nplt.figure(figsize=(5,5))\n\nbars = plt.bar(labels, errors, color=['skyblue', 'salmon'])\nplt.ylabel('Reconstruction Error')\n\n# Annotate bars with error values\nfor bar in bars:\n    height = bar.get_height()\n    plt.annotate(f'{height:.4f}',\n                 xy=(bar.get_x() + bar.get_width() / 2, height),\n                 xytext=(0, 3),  # 3 points vertical offset\n                 textcoords=\"offset points\",\n                 ha='center', va='bottom')\n\nplt.ylim(0, max(errors)*1.2)\nplt.show()\n\nplt.figure(figsize=(5,5))\n\nranks = [rank_Z, rank_Z_nl]\nlabels_rank = ['Z (Linear)', 'Z_nonlinear (Non-linear)']\n\nbars_rank = plt.bar(labels_rank, ranks, color=['lightgreen', 'gold'])\nplt.ylabel('Matrix Rank')\n\n# Annotate bars with rank values\nfor bar in bars_rank:\n    height = bar.get_height()\n    plt.annotate(f'{int(height)}',\n                 xy=(bar.get_x() + bar.get_width() / 2, height),\n                 xytext=(0, 3),  # 3 points vertical offset\n                 textcoords=\"offset points\",\n                 ha='center', va='bottom')\n\nplt.ylim(0, m + 1)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Reconstruction Error Comparison](index_files/figure-html/fig-nonlinear-rank-recovery-output-1.png){#fig-nonlinear-rank-recovery-1 width=440 height=411}\n:::\n\n::: {.cell-output .cell-output-display}\n![Matrix Rank Comparison](index_files/figure-html/fig-nonlinear-rank-recovery-output-2.png){#fig-nonlinear-rank-recovery-2 width=436 height=411}\n:::\n\nA comparison least squares with non-linear activation function\n:::\n\n\n#### Notes on Scaling\n\nThe $W$ matrix will scale up in $O(N^2)$ so that with more data samples it can become too large to handle well. The problem however can be solved with a random $w$ and with $W$ alone under these conditions. A lower rank $W$ could help under conditions where the size of $N$ is large. \n\n$$ W = Q Z^T $$\n\nwhere $Q$ is a matrix of orthonormal columns and $Z$ is a matrix of size $d \\times N$. In this case the product $U^TW$ for any particular sample $u_i$ will be giben by $\\sigma((u_i^TQ)Z^T)$. This lower rank matrix leads to the topic of convolutional neural networks (CNNs) which make extensive use of a reduced rank matrix. The benefit is that it can improve the computational speed by exploiting a sparse structure in the matrix $W$.\n\nThis becomes more important when the layers of a SLP are combined into a deep neural network (DNN).  \n\n$$y = R(u; \\theta) = w^T \\sigma(W^{(L)} \\sigma(W^{(L-1)} \\cdots \\sigma(W^{(1)}u + a^{(1)})) + a^{(L-1)}) + a^{(L)}$$\n\nwhere $L$ is the number of layers in the network. This is a chain of affine transformations followed by non-linear activation functions and can be expensive to compute in the case where $N$ is large.\n\n## Convolutional Neural Networks (CNNs)\n\nA convolutional neural network makes use of a matrix operator that produces the same result as a discrete convolution. \n\n### Convolution Operator\n\nThe 1D convolutional operator $\\ast$ in the discrete case is defined as:\n\n$$ (f \\ast g)[n] = \\sum_{m=-\\infty}^{\\infty} f[m]g[n-m] $$\n\nIn the case of a 2D convolution, the operator is defined as:\n\n$$ (f \\ast g)[n,m] = \\sum_{i=-\\infty}^{\\infty} \\sum_{j=-\\infty}^{\\infty} f[i,j]g[n-i,m-j] $$\n\nIt is also an operation defined in the continuous domain as:\n\n$$ (f \\ast g)(x) = \\int_{-\\infty}^{\\infty} f(y)g(x-y)dy $$\n\nThe operation is one that is fundamental to mathematics and shows up in many different applications including, signal processing, image processing, control theory, probability theory, solutions to ordinary and partial differential equations where it is known as the Green's function, and in the solution of integral equations. Another such home that is has found is in deep learning. The convolution has some intuitive properties that make it useful in any system that is linear and time/shift invariant (LTI). \n\n**Properties of Convolution**\n\n1. Linearity: $f \\ast (\\alpha g + \\beta h) = \\alpha f \\ast g + \\beta f \\ast h$\n2. Commutativity: $f \\ast g = g \\ast f$\n3. Associativity: $f \\ast (g \\ast h) = (f \\ast g) \\ast h$\n\nRather than explain convolution at length here, the interested reader is encouraged to look at the [Convolution Wikipedia page](https://en.wikipedia.org/wiki/Convolution) for some excellent properties and visual examples to build intuition. \n\nIn the context of image and data processing, the convolution is closely related to a correlation filter, the two only differe by a rotation of 180 in the convolutional kernel (the function being convolved with the input). This is an important consideration when it comes to working with learned convolutional kernels, since they can be equally interpreted as correlation filters.\n\nAnother important property to know is that the convolution operation has a close relationship with the fourier transform. The convolution in the spatial domain is equivalent to a pointwise multiplication in the frequency domain. This is known as the convolution theorem:\n\n$$ \\mathcal{F}(f \\ast g) = \\mathcal{F}(f) \\cdot \\mathcal{F}(g) $$\n\nWhen it comes to computing large convolutions for two function $f(x)$ and $g(x)$, the convolution theorem can be used to compute the convolution in the frequency domain, which is much faster than the spatial domain.\n\n$$ f \\ast g = \\mathcal{F}^{-1}(\\mathcal{F}(f) \\cdot \\mathcal{F}(g)) $$\n\nFor more details with visual explanations, another good resource is the UBC CPSC 425 course on [Computer Vision](https://www.cs.ubc.ca/~lsigal/teaching.html) with slides from [Lecture 3b](https://www.cs.ubc.ca/~lsigal/425_2024W1/101/Lecture3b.pdf) and [Lecture 4](https://www.cs.ubc.ca/~lsigal/425_2024W1/101/Lecture4.pdf).\n\n### Convolution in CNNs\n\nA convolutinal neural network (CNN) is a type of neural network where the linear mapping involves a convolution operation instead of a dense weight matrix $W$. The goal of this section is to define the 2D discrete convolution and show how it can be expressed as a sparse matrix.\n\n**Single Layer Perceptron (SLP) vs Convolutional Neural Network (CNN)**\n\nThe single layer of a perceptron given earlier is of the form $y = w^T \\sigma(Wu + a)$, where $W$ is the weights matrix, $w$ is the weights vector, $u$ is the input, and $a$ is the bias vector. A convolutional network improves the efficiency of computation by exploiting a sparse structure with fewer parameters in the weights matrix. Replacing $W$ with a sparse convolutional matrix $C$.\n\n---\n\n**Definition: Convolutional Operation**\n\nLet $\\vec{u}$ be the flattened input image $\\mathcal{I}$, and let $\\mathcal{K}$ be the convolutional kernel. The convolutional operation is defined as:\n\n$$ Y[s,t] = \\mathcal{K} \\ast \\mathcal{I} = \\sum_{i=-\\infty}^{\\infty} \\sum_{j=-\\infty}^{\\infty} \\mathcal{K}[i,j] \\mathcal{I}[s-i,t-j]$$\n\n  - $Y[s,t]$ is the output at position $(s,t)$\n  - $N$ and $M$ are the dimensions of the kernel $\\mathcal{K}$\n  - $\\mathcal{K}[i,j]$ is the element in the $i$-th row and $j$-th column of the kernel\n\nThe kernel slides across the input image, producing a weighted sum at each valid position to give output $Y$. The indices are clipped from infinity to the correct size depending on the padding, size of kernel, and the stride.\n\nIt is a linear operation so that every element of $Y$ is a linear combination of the input and weights elements, indicating that it can be expressed as a matrix multiplication with the flattened image $\\vec{u}$ and the flattened kernel $\\vec{k}$. \n\n#### Example: Convolution of a $2\\times 2$ Kernel with a $4\\times 4$ Image\n\n**Input Image**:\n$$\n\\mathcal{I} =\n\\begin{bmatrix}\nu_{1,1} & u_{1,2} & u_{1,3} & u_{1,4} \\\\\nu_{2,1} & u_{2,2} & u_{2,3} & u_{2,4} \\\\\nu_{3,1} & u_{3,2} & u_{3,3} & u_{3,4} \\\\\nu_{4,1} & u_{4,2} & u_{4,3} & u_{4,4} \\\\\n\\end{bmatrix}\n$$\n\n**Kernel**:\n$$\n\\mathcal{K} =\n\\begin{bmatrix}\nk_{1,1} & k_{1,2} \\\\\nk_{2,1} & k_{2,2} \\\\\n\\end{bmatrix}\n$$\n\n**Output**:\nThe output of the convolution will be a $3 \\times 3$ matrix, since the kernel slides over the $4 \\times 4$ image with no padding and a stride of 1.\n\n$$\nY =\n\\begin{bmatrix}\ny_{1,1} & y_{1,2} & y_{1,3} \\\\\ny_{2,1} & y_{2,2} & y_{2,3} \\\\\ny_{3,1} & y_{3,2} & y_{3,3} \\\\\n\\end{bmatrix}\n$$\n\nNote that the output indexing loses the first and last row and column because there is no padding. In cases with zero padding, then all undefined indices of the input are set to zero when using the convolution formula and reaching undefined indices.\n\nEach element $y_{s,t}$ of the output is given by:\n$$\ny_{s,t} = \\sum_{i=1}^{2} \\sum_{j=1}^{2} \\mathcal{K}[i,j] \\cdot \\mathcal{I}[(s+2)-i, (t+2)-j]\n$$\n\nThe addition of $2$ in the indexing is due to the size of the kernel being $2 \\times 2$ and the choice to index $y$ starting from $1$ instead of $3$ for the case with no padding.\n\n**Flatten the Input Image**:\n\nFlatten the $4 \\times 4$ image $\\mathcal{I}$ into a column vector $\\vec{u} \\in \\mathbb{R}^{16}$:\n$$\n\\text{flatten}\\left(\\mathcal{I}\\right) = \\vec{u} = \n\\begin{bmatrix}\nu_{1,1} & u_{1,2} & u_{1,3} & u_{1,4} &\nu_{2,1} & u_{2,2} & u_{2,3} & u_{2,4} &\nu_{3,1} & u_{3,2} & u_{3,3} & u_{3,4} &\nu_{4,1} & u_{4,2} & u_{4,3} & u_{4,4}\n\\end{bmatrix}^T\n$$\n\n**Sparse Convolution Matrix**:\n\nThe convolution operation is expressed as a matrix multiplication:\n$$\n\\text{flatten}\\left( Y \\right) = \\mathbf{C} \\vec{u}\n$$\n\nHere, $\\mathbf{C}$ is the sparse matrix representation of the $2 \\times 2$ kernel, with size $9 \\times 16$ (matching the size of the output vector and the input vector). The non-zero entries in each row of $\\mathbf{C}$ correspond to the flattened values of $\\mathcal{K}$.\n\nLooking at the first few entries of the output $Y$ defines the matrix entries:\n\n  - $y_{1,1} = k_{2,2}u_{1,1} + k_{2,1}u_{1,2} + k_{1,2}u_{2,1} + k_{1,1}u_{2,2}$\n  - $y_{1,2} = k_{2,2}u_{1,2} + k_{2,1}u_{1,3} + k_{1,2}u_{2,2} + k_{1,1}u_{2,3}$\n  - $y_{1,3} = k_{2,2}u_{1,3} + k_{2,1}u_{1,4} + k_{1,2}u_{2,3} + k_{1,1}u_{2,4}$\n\n\n$$\n\\mathbf{C} =\n\\begin{bmatrix}\nk_{2,2} & k_{2,1} & 0      & 0      & k_{1,2} & k_{1,1} & 0      & 0      & 0      & 0      & 0      & 0      & 0      & 0      & 0      & 0      \\\\\n0      & k_{2,2} & k_{2,1} & 0      & 0      & k_{1,2} & k_{1,1} & 0      & 0      & 0      & 0      & 0      & 0      & 0      & 0      & 0      \\\\\n0      & 0      & k_{2,2} & k_{2,1} & 0      & 0      & k_{1,2} & k_{1,1} & 0      & 0      & 0      & 0      & 0      & 0      & 0      & 0      \\\\\n0      & 0      & 0      & 0        & k_{2,2} & k_{2,1} & 0      & 0      & k_{1,2} & k_{1,1} & 0      & 0      & 0      & 0      & 0      & 0    \\\\\n0      & 0      & 0      & 0        & 0      & k_{2,2} & k_{2,1} & 0      & 0      & k_{1,2} & k_{1,1} & 0      & 0      & 0      & 0      & 0    \\\\\n\\vdots & \\vdots  & \\vdots  & \\vdots & \\vdots & \\vdots  & \\vdots  & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n\\end{bmatrix}\n$$\n\nThen using this matrix and the flattened input image, a flattened output vector can be computed as $$\\text{flatten}\\left(Y \\right) = C \\vec{u}$.\n\nSo the convolution operation gives a matrix that only has $4$ parameters out of the $9 \\times 16 = 144$ total elements, with most of the entries being zero. This can be highly efficient for compuations in a neural network for spatially invariant features in the input data. The sparse structure of the matrix can also be exploited for efficient computation.\n\n#### Channels in Convolutional Neural Networks\n\nThe data being processed in a CNN can have multiple channels, such as color images with $3$ channels. The images may also be processed in batches, adding yet another dimension to the input data. For a single image that is size $\\{C,H,W\\}$ where $C$ is the number of channels, $H$ is the height, and $W$ is the width, a different convolutional kernel is applied as a mapping from $C_{in}$ channels to $C_{out}$ channels. To flatten the input image with channels, the flattened single channels are stacked vertically to form a single column vector.\n\nFor $k$ input channels and $l$ output channels:\n\n$$ y = \\begin{bmatrix}\nW_{1,1} & W_{1,2} & \\cdots & W_{1,k} \\\\\nW_{2,1} & W_{2,2} & \\cdots & W_{2,k} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nW_{l,1} & W_{l,2} & \\cdots & W_{l,k} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nu_{c=1} \\\\\nu_{c=2} \\\\\n\\vdots \\\\\nu_{c=k} \\\\\n\\end{bmatrix}\n$$\n\nThe $W$ are the individual convolutional kernel maps for each input to output channel. The input is a flattened tensor of size $k \\times H \\times W$, and the output is a flattened tensor of size $l \\times H \\times W$.\n\nTo extend the CNN structure to accept batches, the input data is pooled together into a matrix of flattned input data, where each column is a flattened input image. For a batch size of $N$, the input data is of size $N \\times k \\times H \\times W \\times N$ and the output data is of size $N \\times l \\times H \\times W$.\n\n$$ Y_{\\text{batch}} = \\begin{bmatrix}\nW_{1,1} & W_{1,2} & \\cdots & W_{1,k} \\\\\nW_{2,1} & W_{2,2} & \\cdots & W_{2,k} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nW_{l,1} & W_{l,2} & \\cdots & W_{l,k} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nu_{1,c=1} & u_{2,c=1} & \\cdots & u_{N,c=1} \\\\\nu_{1,c=2} & u_{2,c=2} & \\cdots & u_{N,c=2} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nu_{1,c=k} & u_{2,c=k} & \\cdots & u_{N,c=k} \\\\\n\\end{bmatrix}\n$$\n\n#### Deep CNNs\n\nA deep CNN wil chain multiple convolutional layers together, including a non-linear activation function and bias after each later:\n\n$$ y = \\sigma(W^{(L)} \\sigma(W^{(L-1)} \\cdots \\sigma(W^{(1)}u + a^{(1)}) + a^{(L-1)}) + a^{(L)} $$\n\nA famous implementation of a deep CNN that broke new ground in the world of image processing is the ResNet architecture [@Kaiming2015]. The ResNet was able to train very deep networks with hundreds of layers by using skip connections that bypassed one or more layers. Each sequential layer in the architecture is to train a change in the residual rather than the entire output to the next layer.\n\n$$ u_{n+1} = u_n + h \\sigma(W_n u_n + a_n) $$\n\nWhen $h$ becomes small, this resembles the Euler method for solving ordinary differential equations where $\\frac{du}{dt} = \\sigma(W_t u + a_t)$. Where the parameters are also time dependent.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}