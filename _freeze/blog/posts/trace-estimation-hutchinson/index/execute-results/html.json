{
  "hash": "87c3132d4fb73a184bb26be02905f581",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Trace Estimation for Implicit Matrices\"\nsubtitle: \"A Hutchinson's and Hutch++ Survey\"\ndate: 2026-01-18\nauthor: \"Simon Ghyselincks\"\ndescription: >-\n  Implicit matrix trace estimation using only matrix-vector products is a problem that commonly arises in many areas of scientific computing and machine learning. This work explores randomized algorithms including Hutchinson's and Hutch++.\ncategories:\n    - Randomized Algorithms\n    - Linear Algebra\n    - Machine Learning\n\nbibliography: references.bib\nbiblatexoptions: \"style=numeric,sorting=nyt\"\nbibliostyle: numeric-comp\n\ndraft: false\n\nexecute:\n  jupyter: python3\n  freeze: true\n\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n    toc: true\n    number-sections: true\n    number-depth: 2             # Stops numbering at X.X (excludes X.X.X)\n    html-math-method: mathjax\n    fontsize: 12pt              # Slightly smaller base font\n    linestretch: 1.4          # Tighter line spacing (default is usually 1.5)\n   \n---\n\n\n\n\n\n<style>\n/* BOXED THEOREMS/DEFINITIONS */\n.definition, .theorem, .lemma, .proposition {\n  background-color: #f8f9fa;\n  border: 1px solid #dee2e6;\n  border-left: 4px solid #444;\n  padding: 1em;\n  border-radius: 4px;\n  margin-top: 1em;\n  margin-bottom: 1em;\n}\n\n/* THEOREM TITLE STYLING (The Fix) */\nspan.theorem-title {\n  display: block;          /* Forces the text to the next line */\n  margin-bottom: 0.5rem;   /* Adds space between title and body */\n  font-weight: 900;        /* Make it extra bold */\n  color: #333;\n}\n</style>\n\n$$\n\\newcommand{\\mA}{\\mathbf{A}}\n\\newcommand{\\mI}{\\mathbf{I}}\n\\newcommand{\\mH}{\\mathbf{H}}\n\\newcommand{\\mD}{\\mathbf{D}}\n\\newcommand{\\mF}{\\mathbf{F}}\n\\newcommand{\\mQ}{\\mathbf{Q}}\n\\newcommand{\\mS}{\\mathbf{S}}\n\\newcommand{\\mG}{\\mathbf{G}}\n\\newcommand{\\mU}{\\mathbf{U}}\n\\newcommand{\\mV}{\\mathbf{V}}\n\\newcommand{\\mY}{\\mathbf{Y}}\n\\newcommand{\\vv}{\\mathbf{v}}\n\\newcommand{\\vz}{\\mathbf{z}}\n\\newcommand{\\vw}{\\mathbf{w}}\n\\newcommand{\\va}{\\mathbf{a}}\n\\newcommand{\\ve}{\\mathbf{e}}\n\\newcommand{\\tr}{\\operatorname{Tr}}\n\\newcommand{\\Var}{\\operatorname{Var}}\n\\newcommand{\\Pr}{\\mathbb{P}}\n$$\n\n::: {.callout-note appearance=\"simple\"}\n## Abstract\nImplicit matrix trace estimation using only matrix-vector products is a problem that commonly arises in many areas of scientific computing and machine learning. When the matrix is only accessible through matrix-vector products $\\mA \\vv$ or is excessively large, classical deterministic methods for computing the trace are infeasible. This work presents a survey and comparative analysis of randomized algorithms for trace estimation, building from the foundational Hutchinson's estimator to modern variance-reduced techniques like Hutch++. We synthesize the evolution of theoretical guarantees, moving from initial variance-based analysis to rigorous $(\\epsilon, \\delta)$-concentration bounds. Furthermore, we evaluate the practical performance of these methods through numerical experiments on matrices with varying spectral properties. We empirically verify the optimal convergence rates of Hutch++ on matrices with decaying spectra and discuss the trade-offs between different probing vector distributions. \n\nCode is available at [GitHub Gist](https://gist.github.com/chipnbits/a0f572042b04e5292cde6038be407002)\n:::\n\n# Introduction\n\nImplicit matrix trace estimation for a matrix $\\mA$ using only the matrix-vector product $\\mA \\vv$ over some set of $\\mA \\vv_1,\\mA \\vv_2,...\\mA \\vv_m \\in \\mathbb{R}^N$ is a problem that commonly arises in scientific computing and machine learning [@UbaruSaad2018]. When $\\mA$ is only accessible through the map $x \\mapsto \\mA x$, there is no direct access to its matrix elements, and we call this an implicit representation. Even in the case where $\\mA$ is explicitly computable, it may be of an excessively large dimension, making it infeasible to store and compute the full matrix. Similarly, for $\\mA \\in \\mathbb{R}^{N \\times N}$, although $\\tr(\\mA)$ is simply the sum of diagonal elements, it requires evaluating $\\sum_{i\\in [N]} e_i^\\top \\mA e_i$, which for large $n$ may be computationally expensive, intractable, or unnecessary for the level of precision required. \n\nOften these problems arise within an iterative process, where an estimation will suffice under the expectation that future algorithmic steps will further refine the problem solution [@woodruffOptimalQueryComplexities]. This problem formulation is well suited to randomized numerical linear algebra (RNLA) techniques, and as discussed below, can even be effectively paired with other randomized algorithms such as low-rank matrix estimation for further efficiency gains [@meyer2021HutchOptimalStochastic]. \n\nThe goal of trace *estimation* then is to find an approximation within some error tolerance such that the total required matrix-vector products scale sublinearly in $N$, avoiding $O(N)$ complexity. A naive approach would be to randomly sample a subset of the diagonal elements of $\\mA$ as an estimator, but the diagonal elements may be highly concentrated, resulting in the same variance issues posed by sparse sampling [@avron2011RandomizedAlgorithmsEstimating]. Thus we must employ more sophisticated methods to gain better approximations at a cheaper cost, as measured by both computational complexity and the total matrix-vector products. This motivates the need for generalizable methods capable of probing the structure of $\\mA$ using a limited number of matrix-vector products or other implicit representations.\n\n## Trace Estimation Applications\nExamples of trace estimation problems are abundant [@UbaruSaad2018]. In deep learning, large and complex models often require the estimation of traces of Hessian matrices $\\mH$ for optimization and uncertainty quantification. A common architecture such as ResNet-50 has a $25 \\text{ million} \\times 25 \\text{ million}$ matrix $\\mH$ that is prohibitive to store, but whose matrix-vector product $\\mH \\vv$ can be efficiently computed using Pearlmutter's trick [@pearlmutter1994fast]. High-dimensional trace estimation is also used for training Physics Informed Neural Networks (PINNs) [@HU2024116883]. In probabilistic machine learning, trace estimation is used in score-matching methods [@Song2019SlicedSM].\n\n## Scope of this Review\nThis article synthesizes the progression of Randomized Numerical Linear Algebra (RNLA) methods for trace estimation, analyzes their theoretical properties, and evaluates their performance through numerical experiments. Specifically, we:\n\n1. Review the foundational Hutchinson's estimator [@Hutchinson01011990].\n2. Analyze the $(\\epsilon, \\delta)$ bounds derived by @avron2011RandomizedAlgorithmsEstimating.\n3. Implement and verify the Hutch++ algorithm [@meyer2021HutchOptimalStochastic], which combines low-rank approximation with stochastic estimation.\n4. Compare these methods numerically on matrices with different spectral decay properties.\n\n# Background {#sec-background}\n\n## Notation and Definitions\nIn this work, lower case $a$ denotes a scalar, capital $A$ denotes a random variable, lower case bold $\\va$ denotes a vector, and upper case bold $\\mA$ denotes a matrix. A summary of the notation used is found below in @tbl-notation.\n\n::: {style=\"max-width: 400px; margin: 0 auto;\"}\n| Symbol | Description |\n| :--- | :--- |\n| $\\mA \\in \\mathbb{R}^{N \\times N}$ | Symmetric Positive Semi-Definite (SPSD) matrix |\n| $\\tr(\\mA)$ | Trace of matrix $\\mA$ |\n| $\\lambda_i$ | The $i$-th eigenvalue of $\\mA$ |\n| $\\vv$ | Vector in $\\mathbb{R}^N$ |\n| $m$ | Number of Matrix-Vector Product (MVP) $\\mA \\vv$ queries |\n| $\\epsilon$ | Relative error tolerance |\n| $\\delta$ | Probability of failure |\n| $\\|\\mA\\|_F$ | Frobenius norm, $\\sqrt{\\sum_{i,j} A_{ij}^2}$ |\n: Summary of Notation {#tbl-notation .table-sm}\n:::\n\n## Trace and SPSD Matrices\nThe trace operator $\\tr(\\mA)$ is defined only over square matrices and has two equivalent definitions: either the sum of the diagonal elements or the sum of the eigenvalues $\\lambda_1, \\lambda_2, \\ldots, \\lambda_N$ of $\\mA$,\n$$\n\\tr(\\mA) := \\sum_{i=1}^N \\mA_{ii} = \\sum_{i=1}^N \\lambda_i.\n$$\n\n#### Trace as the sum of eigenvalues\nRecall that for a square matrix $\\mA$, the eigenvalues are defined as the roots of the characteristic polynomial\n$$\np(t) := \\det(\\mA - t\\mI).\n$$\nThe expansion of the determinant has $t^n$ and $t^{n-1}$ coefficients that will only arise from the products of diagonal elements. The first two terms then are\n$$\np(t)= (-1)^n \\left(t^n - \\tr(\\mA) t^{n-1} + \\cdots + (-1)^n \\det(\\mA)\\right),\n$$\nso the coefficient of $t^{n-1}$ is $-\\tr(\\mA)$. But the characteristic polynomial is also defined by its roots which are the eigenvalues, giving\n$$\np(t) = \\prod_{i=1}^N (\\lambda_i - t) = (-1)^n \\left( t^n - \\left(\\sum_{i=1}^N \\lambda_i\\right) t^{n-1} + \\cdots + \\prod_{i=1}^N \\lambda_i \\right).\n$$\nSince the two definitions are equivalent and valid for all $t$, the coefficients must be equal, and we have shown that $\\tr(\\mA) = \\sum_{i=1}^N \\lambda_i$.\n\n#### Symmetric Positive Semi-Definite Matrices\nThe analysis and algorithms ahead are restricted to symmetric positive semi-definite (SPSD) matrices, where $A = A^\\top$ and all eigenvalues are non-negative ($\\lambda_i \\geq 0$), denoted $\\mA \\succeq 0$. This restriction is commonly imposed in the literature, as it simplifies the theoretical analysis and many of the aforementioned practical problems have SPSD matrices [@meyer2021HutchOptimalStochastic], while analysis by @avron2011RandomizedAlgorithmsEstimating also assumes this. An SPSD matrix has useful properties such as real-valued eigenvalues, orthogonal eigenvectors, a diagonalizable form which coincides with the singular value decomposition, strictly non-negative diagonal elements, and a non-negative quadratic form $\\vv^\\top \\mA \\vv \\geq 0$ for all $\\vv \\in \\mathbb{R}^n$.\n\n#### Matrix-Vector Product Oracle\nTo generalize the problem setting to both large explicit and implicit matrices, we assume only that there exists an *oracle* that can compute matrix-vector products (MVPs) $\\mA \\vz$ for any vector $\\vz \\in \\mathbb{R}^N$. The oracle is assumed to operate at a fixed cost per query, such that the total computational cost of an algorithm is proportional to the number of queries made.\n\n## Problem Statement\nThe goal is to construct a randomized algorithm for sampling $\\mA \\vv$ that will give an estimate of the trace $\\tr(\\mA)$ for an SPSD matrix $\\mA \\succeq 0$ with failure rate at most $\\delta \\in (0,1)$ and relative error tolerance $\\epsilon \\in (0,1)$.\n\n::: {#def-estimator .definition}\n## Randomized Trace Estimator\n\nA randomized estimator $T$ is an $(\\epsilon, \\delta)$-approximation of $\\tr(\\mA)$ if:\n$$\n\\Pr\\Big[ | T - \\tr(\\mA) | \\leq \\epsilon \\tr(\\mA) \\Big] \\geq 1 - \\delta,\n$$\nwhere $\\epsilon \\in (0, 1)$ is the error tolerance and $\\delta \\in (0, 1)$ is the failure probability.\n:::\n\nWhile many estimators exist, the challenge is to find an unbiased estimator $T$ that minimizes the number of MVP queries $m$ required for a given $(\\epsilon, \\delta)$-approximation.\n\n## Prior Work and Complexity Bounds\n@Hutchinson01011990 first proposed a randomized algorithm for an unbiased trace estimator in 1989 in the context of calculating Laplacian smoothing splines. Its advancements over prior work include the use of Rademacher random variables instead of Gaussian vector entries, and performing a variance analysis of the estimator. However, the analysis does not provide rigorous $(\\epsilon, \\delta)$-bounds for the estimator, focusing instead on variance alone. Later work by @avron2011RandomizedAlgorithmsEstimating in 2011 revisits Hutchinson's estimator and provides the first rigorous $(\\epsilon, \\delta)$-bounds for a variety of related estimators, including Hutchinson's. Their contributions include constructing methods that are oblivious to the basis of $\\mA$ and proving rigorous $O(\\epsilon^{-2} \\ln(1/\\delta))$ bounds for the number of samples required. More recent work by @meyer2021HutchOptimalStochastic improves these guarantees using Hutch++, achieving only \\(O(\\epsilon^{-1} \\ln(1/\\delta))\\) matrix–vector products for a \\((1\\pm\\epsilon)\\) approximation by combining the exact trace estimate for a randomized low-rank approximation with a stochastic estimator for the residual. A summary of prior work is given in @tbl-prior-work.\n\n::: {style=\"max-width: 600px; margin: 0 auto;\"}\n| Algorithm | Query Complexity | Notes |\n| :--- | :--- | :--- |\n| Hutchinson [@Hutchinson01011990] | $O(1/\\epsilon^{2})$ | Original analysis, only variance |\n| Avron & Toledo [@avron2011RandomizedAlgorithmsEstimating] | $O(\\ln(1/\\delta)/\\epsilon^2)$ | Bounds for many classes of random vectors $\\vv$ |\n| Hutch++ [@meyer2021HutchOptimalStochastic] | $O( \\frac{1}{\\epsilon} \\ln(1/\\delta))$ | Optimal complexity, preprocessing with low-rank approximation |\n: Summary of Prior Work on Trace Estimation {#tbl-prior-work}\n:::\n\n# The Hutchinson Estimator {#sec-hutchinson}\n\n@Hutchinson01011990 proposes the Rademacher-based estimator $T_{H}$\n$$\nT_{H} := \\frac{1}{m} \\sum_{j=1}^m \\vv_j^\\top \\mA \\vv_j, \\quad \\vv_j \\in \\{\\pm 1\\}^N \\text{ i.i.d. Rademacher random vectors,}\n$$\nwith $m$ calls to the MVP oracle. This estimator is unbiased, i.e., $\\mathbb{E}[T_H] = \\tr(\\mA)$.\n\n#### Unbiased Estimators\nLet $\\vv$ be a random vector with i.i.d. entries $v_i \\sim V$ such that $\\mathbb{E}[v_i] = 0$ and $\\mathbb{E}[v_i^2] = \\sigma^2$. Then \n$$\n\\begin{align}\n\\mathbb{E}[\\vv^\\top \\mA \\vv]\n&= \\sigma^2 \\tr(\\mA), \\\\\n\\mathrm{Var}(\\vv^\\top \\mA \\vv)\n&= 2 \\sigma^4 \\sum_{i \\neq j} A_{ij}^2 + \\left(\\mathbb{E}\\left[V^4\\right] - \\sigma^4\\right) \\sum_{i} A_{ii}^2.\n\\end{align}\n$$\n\n::: {.proof}\n$$\n\\begin{align*}\n\\mathbb{E}[\\vv^\\top \\mA \\vv]\n&= \\sum_{i,j} A_{ij} \\mathbb{E}[v_i v_j] \\quad \\text{(by linearity of expectation)} \\\\\n&= \\sum_{i} A_{ii} \\mathbb{E}[v_i^2] + \\sum_{i \\neq j} A_{ij} \\mathbb{E}[v_i] \\mathbb{E}[v_j] \\quad \\text{(by independence)} \\\\\n&= \\sigma^2 \\tr(\\mA) \\quad \\text{(since $\\mathbb{E}[v_i] = 0$)}.\n\\end{align*}\n$$\n\nFor the case of variance, we again write out the summation form of expectation with four cases considered:\n$$\n\\begin{align*}\n\\mathbb{E}[(\\vv^\\top \\mA \\vv)^2] &= \\mathbb{E}\\left[\\left(\\sum_{i,j} A_{ij} v_i v_j\\right) \\left(\\sum_{k,l} A_{kl} v_k v_l\\right)\\right] \\\\\n&= \\sum_{i,j,k,l} A_{ij} A_{kl} \\mathbb{E}[v_i v_j v_k v_l] \\\\\n&= \\underbrace{0}_{\\text{one distinct }i,j,k,l} + \\underbrace{\\sigma^4 \\sum_{i \\neq k} A_{ii}A_{kk}}_{i=j, k=l, i\\neq k} + \\underbrace{\\sigma^4 \\sum_{i \\neq j}  A_{ij}^2}_{i=k, j=l, i\\neq j} + \\underbrace{\\sigma^4 \\sum_{i \\neq j}  A_{ij}^2}_{i=l, j=k, i\\neq j} + \\underbrace{\\mathbb{E}\\left[V^4 \\right] \\sum_{i} A_{ii}^2}_{i=j=k=l} \\\\\n\\Var(\\vv^\\top \\mA \\vv) &= \\mathbb{E}[(\\vv^\\top \\mA \\vv)^2] - \\sigma^4 \\sum_{i,j}A_{ii}A_{jj} \\\\\n&= 2 \\sigma^4 \\sum_{i \\neq j} A_{ij}^2 + \\left(\\mathbb{E}\\left[V^4\\right] - \\sigma^4\\right) \\sum_{i} A_{ii}^2\n\\end{align*}\n$$\n:::\n\nWhen at least one index is distinct, the expectation is zero by independence and zero mean. When indices are paired, we get contributions of $\\sigma^2$ for each unique double pair. When all four indices are equal, we get a contribution of $\\mathbb{E}[V^4]$. The variance is then found by subtracting the square of the mean. \n\nAny random vector with the above properties will then function as an unbiased estimator when $\\Var(V)=\\sigma^2=1$ and will have minimum variance when $\\mathbb{E}[V^4] - \\sigma^4$ is minimized. The Rademacher random variable satisfies $\\mathbb{E}[V] = 0$, $\\Var(V) = 1$, and minimizes $\\mathbb{E}[V^4] - \\sigma^4$. In fact, by Jensen's inequality for any $V$, $\\mathbb{E}[V^4] \\geq (\\mathbb{E}[V^2])^2 = \\sigma^4$, such that the minimum is achieved when $\\mathbb{E}[V^4] = \\sigma^4$. Thus, the Rademacher distribution gives the minimum variance unbiased estimator for the trace using this framework of MVPs with i.i.d. entries. By extension, we expect this to translate to the best possible $\\epsilon, \\delta$ bounds when applying concentration inequalities, as is seen below in Section~\\ref{sec:avron}.\n\nNote that because $\\vv^\\top \\mA \\vv$ is an unbiased estimator, the average of $m$ independent samples is also unbiased with variance reduced by a factor of $m$. This is because for independent random variables $X_1, X_2, \\ldots, X_m$, we have $\\Var\\left(\\frac{1}{m} \\sum_{i=1}^m X_i\\right) = \\frac{1}{m^2} \\sum_{i=1}^m \\Var(X_i) = \\frac{1}{m} \\Var(X_1)$.\n\nLet $\\vv_1, \\ldots, \\vv_m$ be i.i.d. Rademacher random vectors. Then the Hutchinson estimator $T_H$ is unbiased with variance\n$$\n\\mathbb{E}[T_H] = \\tr(\\mA), \\quad \\Var(T_H) = \\frac{1}{m} \\left( 2 \\sum_{i \\neq j} A_{ij}^2 \\right).\n$$\nThis is the minimum variance unbiased estimator using i.i.d. entries with a mean of zero for the random vectors $\\vv_j$, *for a fixed coordinate system*.\n\n#### Variance Analysis\nThe variance only depends on the off-diagonal elements of $\\mA$, so in the special case of a diagonal matrix, the variance is zero. In the context of SPSD matrices, this would amount to the spectral basis being aligned with the standard basis. This estimator clearly performs best when the diagonal elements dominate the off-diagonal elements, or equivalently when the eigenvectors are closely aligned with the standard basis. This poses the question: are there better choices of random vectors that are oblivious to the basis of $\\mA$? If the eigenbasis of $\\mA$ is known, then one could trivially perform a change of basis on $\\vv$ to align it with the diagonalization of $\\mA$.\n\nRademacher vectors are sensitive to the basis in which $\\mA$ is represented, while the Gaussian version of the estimator is rotationally invariant, however at the cost of strictly higher variance. Given i.i.d. standard Gaussian vector entries, the fourth moment is $\\mathbb{E}[G^4] = 3$, giving the Gaussian trace estimator\n$$\n\\Var(T_G) =  \\frac{2}{m} \\left( \\sum_{i \\neq j} A_{ij}^2 + \\sum_{i} A_{ii}^2 \\right)= \\frac{2}{m} \\|\\mA\\|_F^2.\n$$\nHowever, for matrix $\\mA$ there are no guarantees on how well aligned the eigenbasis is to the standard basis, and so the variance for Rademacher may approach that of Gaussian in the worst case. In both cases, the variance in the worst case scales with the squared Frobenius norm $\\|\\mA\\|_F^2$ which is equal to the sum of squared eigenvalues $\\sum_{i} \\lambda_i^2$.\n\n## Limitations of the Original Analysis\n\nWhile Hutchinson's derivation proves unbiasedness and minimal variance among independent vector distributions, the rest of the analysis is focused on the Laplacian smoothing splines application. It is interesting to note the large number of citations that the work has received since its publication, largely due to the variance analysis of the generalized estimator and not for the specific application.\n\nThe focus purely on variance is limiting, as it does not translate directly to optimal $(\\epsilon, \\delta)$ bounds. The extension of the analysis to $(\\epsilon, \\delta)$-approximations that later follows is presented in the next section. As @avron2011RandomizedAlgorithmsEstimating point out, for the simple case where $\\mA$ is a SPSD matrix of all $1$'s, the trace is $N$ but the variance is $O(N^2)$. This precludes the use of Chebyshev's inequality as a concentration bound, since for a single sample $m=1$, we have $\\Pr[ |T_G-\\tr \\mA| \\geq \\epsilon \\tr\\mA ] \\leq \\frac{2}{\\epsilon^2} = \\delta$, which is trivially $\\delta > 1$ for any $\\epsilon < 1$. This motivates the need for a more robust analysis that can provide meaningful bounds for all SPSD matrices.\n\n# Theoretical Analysis of $(\\epsilon, \\delta)$-Estimators {#sec-avron}\n\n@avron2011RandomizedAlgorithmsEstimating revisit the Hutchinson estimator in 2011 to provide the first instance of rigorous $(\\epsilon, \\delta)$-guarantees. Their work generalizes the analysis to a broader class of probing vectors than solely Rademacher or Gaussian and addresses the issue of basis sensitivity with randomized mixing matrices. \n\n::: {#def-avron .definition}\n## Avron and Toledo Estimators\nThe three main estimators analyzed by Avron and Toledo are:\n$$\n\\begin{align}\n    T_{GM} &= \\frac{1}{m} \\sum_{j=1}^m \\vv_j^\\top \\mA \\vv_j, \\quad \\vv_j \\in \\{\\vv \\mid \\text{ i.i.d. entries }\\sim \\mathcal{N}(0,1)\\}, \\\\\n    T_{RM} &= \\frac{1}{m} \\sum_{j=1}^m \\vv_j^\\top \\mA \\vv_j, \\quad \\vv_j \\in \\{\\vv \\mid \\|\\vv\\|=N, \\ \\mathbb{E}\\vv^\\top \\mA \\vv=\\tr \\mA\\}, \\\\\n    T_{HM} &= \\frac{1}{m} \\sum_{j=1}^m \\vv_j^\\top \\mA \\vv_j, \\quad \\vv_j \\in \\{\\vv \\mid \\text{ i.i.d. entries } \\sim \\{-1,1\\} \\}, \\\\\n    T_{UM} &= \\frac{N}{m} \\sum_{j=1}^m \\vv_j^\\top \\mA \\vv_j, \\quad \\vv_j \\in \\{\\ve_1, \\ve_2, \\ldots, \\ve_N\\}.\n\\end{align}\n$$\n:::\n\nThe normalized Rayleigh-quotient estimator $T_{RM}$ and the unit vector estimator $T_{UM}$ are new forms not previously discussed by Hutchinson. The advantage of the newly proposed estimators is that they require fewer random bits to generate—$O(\\log n)$ versus $\\Omega(n)$ for the others—as their sample spaces are smaller. To address the basis sensitivity posed by the sparse sampling regime of $T_{UM}$, the authors use a unitary random mixing matrix $\\mathcal{F}=\\mF \\mD$ based on the Fast Johnson-Lindenstrauss (FJL) Transform [@ailonChazelle2006ApproximateNearest].\n\n::: {#def-mixing .definition}\n## Randomized Mixing Matrix\nA randomized mixing matrix $\\mathcal{F} = \\mF \\mD$ is composed of a fixed unitary matrix $\\mF$ (e.g., Discrete Fourier, Discrete Cosine, or Walsh-Hadamard matrix) and a random diagonal matrix $\\mD$ with i.i.d. Rademacher entries.\n:::\n\nWhile there are subtleties to the cost of forming vectors $\\vv_j$ in practice, the MVP computation is typically the dominant cost, so Fourier-type transforms are suggested by Avron and Toledo, in contrast to the Walsh-Hadamard used in the analysis of FJL which requires $N$ to be padded to a power of two [@ailonChazelle2006ApproximateNearest]. \n\nA summary and comparison of the estimators and their properties as derived by @avron2011RandomizedAlgorithmsEstimating is given in @tbl-estimator-comparison. The basis-oblivious estimators $T_{GM}$ and $T_{UM}$ (mixed) have bounds that do not depend on the structure of $\\mA$, while the others do. The mixed unit vector, however, does depend on the dimension $n$. Note that the variance for $T_{RM}$ and $T_{UM}$ (mixed) are not given. Notice that despite worse variance, $T_{GM}$ has a better $(\\epsilon,\\delta)$ bound. All of the results are of order $\\epsilon^{-2} \\ln(1/\\delta)$, indicating a large similarity in their performance and an unfortunate limitation in the error bound. To halve the error we require four times as many samples; however, this result is later improved upon by Hutch++ in @sec-hutchplusplus.\n\n::: {style=\"max-width: 800px; margin: 0 auto;\"}\n| Estimator | Variance | Bound on \\# samples <br> for $(\\varepsilon,\\delta)$-approx | Random bits |\n| :--- | :--- | :--- | :--- |\n| $T_{GM}$ (Gaussian) | $2\\lVert A\\rVert_F^2$ | $20\\varepsilon^{-2}\\ln(2/\\delta)$ | $\\Theta(n)$ |\n| $T_{RM}$ (Rayleigh) | -- | $\\tfrac12\\,\\varepsilon^{-2}n^{-2}\\operatorname{rank}^2(\\mA)\\ln(2/\\delta)\\kappa_f^2(\\mA)$ | $\\Theta(n)$ |\n| $T_{HM}$ (Rademacher) | $2\\big(\\lVert A\\rVert_F^2-\\sum A_{ii}^2\\big)$ | $6 \\epsilon^{-2}\\ln\\left(2 \\operatorname{rank}(\\mA)/\\delta\\right)$ | $\\Theta(\\log n)$ |\n| $T_{UM}$ (Unit Vector) | $n\\sum A_{ii}^2-\\tr^2(\\mA)$ | $\\tfrac12\\,\\varepsilon^{-2}\\ln(2/\\delta)\\,n\\,\\dfrac{\\max_i A_{ii}}{\\tr(\\mA)}$ | $\\Theta(\\log n)$ |\n| $T_{UM}$ (Mixed) | -- | $8\\varepsilon^{-2}\\ln(4n^2/\\delta)\\ln(4/\\delta)$ | $\\Theta(\\log n)$ |\n: Comparison of estimators, variances, sample complexity, and random bit usage. {#tbl-estimator-comparison .table-sm}\n:::\n\n## Gaussian Estimator $T_{GM}$ Example\nFor brevity, only one of the estimator derivations is given in detail, as the full proofs are available in @avron2011RandomizedAlgorithmsEstimating.\nProceeding from the variance in Equation~\\ref{eq:gaussian_variance}, Avron and Toledo take the typical path of applying a Chernoff-style argument. The Gaussian distribution is invariant under rotation so we can diagonalize $\\mA = \\mU \\Lambda \\mU^\\top$ and consider $\\vw_j = \\mU^\\top \\vv_j$ as a Gaussian vector, without loss of generality. Then the estimator becomes\n$$\n   T_{GM} =\\vv^\\top \\mA \\vv = \\frac{1}{m}\\sum_j^{m}\\sum_{i=1}^N \\lambda_i w_{ij}^2 = \\frac{1}{m}\\sum_{i=1}^N \\lambda_i \\sum_{j=1}^m w_{ij}^2,\n$$\nwhere $w_{ij} \\sim \\mathcal{N}(0,1)$, and so each $w_{ij}^2$ is a $\\chi^2$ random variable with one degree of freedom. The sum of $m$ i.i.d. $\\chi^2$ random variables is a $\\chi^2$ random variable with $m$ degrees of freedom, $\\sum_j^m w_{ij}^2 \\sim \\chi^2_m$. \n\nThe tail bounds for the $\\chi^2$ distribution are well studied. Using the following lemma we can derive a weak $(\\epsilon, \\delta)$ bound for $T_{GM}$, after which a stronger bound by Chernoff-style analysis is given by Avron and Toledo.\n\n### Weak $(\\epsilon, \\delta)$ Bound for $T_{GM}$\n\n::: {#lem-chi-squared .lemma}\n## Tail Bound for $\\chi^2$\nLet $X \\sim \\chi^2_m$. Then for any $\\epsilon \\in (0,1)$,\n$$\n    \\Pr\\left[|X - m| \\geq \\epsilon m\\right] \\leq 2 \\exp\\left(-\\frac{m}{8}\\epsilon^2\\right).\n$$\nSource: Lemma 24.2.4 in @Harvey2021Randomized2.\n:::\n\nLet $X_i = \\sum_{j=1}^m w_{ij}^2$, then $X_i \\sim \\chi^2_m$ with $\\mathbb{E}[X_i] = m$. The estimator can be written as\n$$\n    T_{GM} = \\frac{1}{m} \\sum_{i=1}^N \\lambda_i X_i.\n$$\n@lem-chi-squared gives $\\epsilon$ failure probability in terms of $m$ such that $\\delta \\leq 2 \\exp\\left(-\\frac{m}{8}\\epsilon^2\\right)$. Then a standard union bound over all $N$ non-zero eigenvalues gives $\\delta_{\\text{total}} \\leq 2 \\text{rank}(\\mA) \\exp\\left(-\\frac{m}{8}\\epsilon^2\\right)$. Solving for $m$ then gives the required number of samples for an $(\\epsilon, \\delta)$-approximation of \n$$\n    m \\geq \\frac{8}{\\epsilon^2} \\ln\\left(\\frac{2 \\operatorname{rank}(\\mA)}{\\delta}\\right).\n$$\n\nTo improve this bound further, Avron and Toledo apply a Chernoff-style argument directly to the weighted sum of $\\chi^2$ random variables, giving the final bound in @tbl-estimator-comparison. A detailed proof using elementary symmetric polynomials, Markov's inequality, and moment generating functions for $\\chi^2$ random variables is shown in the Appendix.\n\n## Summary of Avron and Toledo Analysis\nBy rederiving the bounds in a Chernoff-style for particular matrix structures, even stronger bounds can be attained in the Gaussian case. For $T_{RM}$ the proof proceeds with a much simpler Hoeffding's inequality argument after bounding the output of the MVP. The original Hutchinson's $T_{HM}$ is bounded by diagonalizing $\\mA$ and applying a lemma for bounding the oblivious Rademacher vectors that have been mixed by the arbitrary unitary matrix that is the basis of $\\mA=\\mU^\\top \\Lambda \\mU$, then union bounding over $\\text{rank}(\\mA)$, finally conjecturing a tighter bound without rank may exist. Comparing bounds directly between estimators is not always conclusive, as the authors themselves conjecture that they have not found the tightest bounds. The final estimator $T_{UM}$ is bounded similarly using a lemma for the mixed unit vectors.\n\nTheir work shows that each estimator requires a specialized treatment to achieve their best possible $(\\epsilon, \\delta)$ bounds, and that the basis sensitivity of estimators can be mitigated by the use of randomized mixing matrices. The $m = O(\\epsilon^{-2})$ dependence on the number of samples greatly limits the practical use of the method for high-accuracy trace estimation, with the suggestion for example of using a $\\epsilon=0.01$ estimate to seed iterative methods for higher accuracy. Reducing this dependence to $\\epsilon^{-1}$ would make higher degrees of accuracy more feasible, motivating the development of Hutch++ in the next section. In many applications of trace estimation the eigenvalue spectrum is dominated by few large values, which contribute the majority of the variance, as is seen in Principal Component Analysis and the SVD decomposition. Given a method of isolating the bulk of the variance, a stochastic estimator can be improved, forming the motivation behind Hutch++ [@meyer2021HutchOptimalStochastic].\n\n\n# Hutch++: Variance Reduction via Low-Rank Approximation {#sec-hutchplusplus}\n\nHutch++ [@meyer2021HutchOptimalStochastic] forms the current state of the art when it comes to optimal trace estimation. For a fixed probability bound $\\delta$ with regular Hutchinson $T_{HM}$, the bound on MVP queries is $m=O(1/\\epsilon^2)$. Remarkably, Hutch++ improves this to $m=O(1/\\epsilon)$, the optimal rate for MVP-based algorithms. The algorithm from the paper is reproduced below in @alg-hutchplusplus.\n\n::: {#alg-hutchplusplus .definition}\n## Algorithm 1: Hutch++ Improved Trace Estimator\n\n**Require:** Matrix-vector multiplication oracle for matrix $\\mA \\in \\mathbb{R}^{n \\times n}$. Number of queries, $m$.  \n**Ensure:** Approximation to $\\tr(\\mA)$.\n\n1.  Sample $\\mS \\in \\mathbb{R}^{n \\times \\frac{m}{3}}$ and $\\mG \\in \\mathbb{R}^{n \\times \\frac{m}{3}}$ with i.i.d. $\\{+1, -1\\}$ entries.\n2.  **Matrix sketch:** Compute an orthonormal basis $\\mQ \\in \\mathbb{R}^{n \\times \\frac{m}{3}}$ for the span of $\\mA \\mS$ (e.g., via QR decomposition).\n3.  **Return** Hutch++$(\\mA) = \\tr(\\mQ^\\top \\mA \\mQ) + \\frac{3}{m} \\tr(\\mG^\\top (\\mI - \\mQ \\mQ^\\top) \\mA (\\mI - \\mQ \\mQ^\\top) \\mG)$.\n:::\n\nThe algorithm splits the MVP budget $m$ into three equal portions to perform the following steps:\n\n1.  **Matrix sketch:** $(m/3)$ MVPs, generate a random sketching matrix $\\mA \\mS$ of size $N \\times m/3$ (where $s \\approx m/3$) and compute the orthonormal basis $\\mQ$ for its range.\n2.  **Low-rank trace:** $(m/3)$ MVPs, the trace of a low-rank \"heavy-hitters\" approximation is computed implicitly as $\\tr(\\hat{\\mA}) = \\tr(\\mQ^\\top \\mA \\mQ)$.\n3.  **Hutchinson's estimator on the residual:** $(m/3)$ MVPs, estimate $\\tr(\\mA - \\hat{\\mA})$ using standard Hutchinson estimator $T_H$ on the residual projection $(\\mI - \\mQ \\mQ^\\top) \\mA (\\mI - \\mQ \\mQ^\\top)$.\n\nMore explicitly, $\\tr(\\mA)$ is decomposed as \n$$\n    \\tr(\\mA) = \\tr(\\hat \\mA) + \\tr(\\mA - \\hat \\mA) = \\tr(\\mQ^\\top \\mA \\mQ) + \\tr((\\mI - \\mQ \\mQ^\\top) \\mA (\\mI - \\mQ \\mQ^\\top)),\n$$\nwhere the first term is computed exactly and the second term with Hutchinson. While $\\mQ$ may not perfectly align with the dominant eigenbasis, it is expected to be a good approximation, and is certain to be a valid projection due to the $QR$ factorization step. This is the opposite of the basis sensitivity issue discussed in @sec-avron, as here the algorithm is exploiting the basis structure of $\\mA$ to reduce variance. \nIn this sense, the authors note that the algorithm is adaptive, as the Rademacher vector alignment is chosen based on the computed basis. Since the residual $\\mA - \\hat \\mA$ is expected to contain only the tail of the spectrum, $\\|\\mA - \\hat \\mA\\|_F^2$ is smaller in expectation, reducing the variance shown in Eqs.~\\ref{eq:gaussian_variance}, \\ref{eq:hutchinson_variance}. The analysis writing and style is more thorough than the original Hutchinson and Avron and Toledo works.\n\n## Theoretical Guarantees\n@meyer2021HutchOptimalStochastic prove the complexity bound of $m=O(1/\\epsilon)$ for an $(\\epsilon, \\delta)$-approximation using Hutch++. The main theorem is reproduced below.\n\n::: {#thm-hutchplusplus-main .theorem}\n## Hutch++ Main Theorem\nFor $m = O\\left(\\sqrt{\\log(1/\\delta)}/\\epsilon + \\log(1/\\delta)\\right)$ MVP queries to a PSD matrix $\\mA$ the Hutch++ algorithm produces an $(\\epsilon, \\delta)$-approximation to $\\tr(\\mA)$.\n:::\n\nThe standard bound on Hutchinson's estimator for general sub-Gaussian vectors $\\vv$, including Gaussian and Rademacher, is similar to the results from @avron2011RandomizedAlgorithmsEstimating. For some constant $c,C$, if $m > c \\log(1/\\delta)$, then with probability at least $1-\\delta$,\n$$\n   |T - \\tr(\\mA)| \\leq C \\sqrt{\\frac{\\log(1/\\delta)}{m}} \\|\\mA\\|_F.\n$$\nSince $\\mA$ is PSD, $\\|\\mA\\|_F \\leq \\tr(\\mA)$, giving the $O(\\epsilon^{-2})$ bound for Hutchinson queries. But as the authors point out this is only tight in the worst case when the diagonalization is sparse, i.e., only one large eigenvalue. Supposing that $\\mQ$ captures the top $k$ eigenvalues of $\\mA$, then the residual Frobenius norm is\n$$\n    \\|\\mA - \\hat \\mA\\|_F^2 = \\sum_{i=k+1}^n \\lambda_i^2 \\leq \\lambda_{k+1} \\sum_{i=k+1}^n \\lambda_i \\leq \\frac{1}{k} \\left(\\sum_{i=k+1}^n \\lambda_i\\right)^2 \\leq \\frac{1}{k} \\tr(\\mA)^2.\n$$\nCombining these results gives the variance of the residual Hutchinson estimator as\n$$\n    |T_{\\hat \\mA} - \\tr(\\hat \\mA)| \\leq C \\sqrt{\\frac{\\log(1/\\delta)}{mk}}  \\tr(\\mA).\n$$\nSetting $k = O(1/\\epsilon)$ and supposing a solved basis for $\\mQ$ already gives an $(\\epsilon, \\delta)$-approximation with $O(1/\\epsilon)$ samples as stated in @thm-hutchplusplus-main. The main remaining challenge is then to show that the randomized sketching step can produce a basis $\\mQ$ that approximates the top $k$ eigenvalues in $O(1/\\epsilon)$ MVPs well enough with high probability. \n\nThe details of matrix sketching lie outside of the scope of this work and the trace estimation paper, but applying Corollary 7 and Claim 1 from @musco2020projectioncostpreservingsketchesproofstrategies shows that for $\\frac{m}{3}\\geq(k+\\log(1/\\delta))$ the residual will stay bounded with high probability $\\geq 1-\\delta$:\n$$\n    \\|\\mA - \\mA \\mQ \\mQ^\\top\\|_F^2 \\leq 2 \\| \\mA - \\mA_k\\|_F^2.\n$$\nThis type of low-rank concentration bound is common in RLNA literature [@woodruff2014SketchingToolNumerical]. The bound is for the residual being at most twice the optimal rank-$k$ approximation error, which is sufficient for replacing the bound in the residual equation by one that is twice as large, preserving the $O(1/\\epsilon)$ complexity. Combining all of these results gives the final proof of @thm-hutchplusplus-main. The only PSD assumption made is in the residual Frobenius norm, providing an avenue for non-PSD extensions which are covered by the authors in their paper, but that are not the focus of this work.\n\n@meyer2021HutchOptimalStochastic also go on to prove that $O(1/\\epsilon)$ is the optimal rate up to a logarithmic factor using a sophisticated reduction to communication complexity for the Gap-Hamming problem. Thus information complexity theory shows that no algorithm using only MVPs can do much better than Hutch++ in the general case. Finally the authors provide a Gaussian sketching variant of Hutch++, shown below in @alg-hutchplusplus-gaussian. The analysis and performance is similar, but with simpler variance bounds. \n\n::: {#alg-hutchplusplus-gaussian .definition}\n## Algorithm 2: Gaussian-Hutch++ (Gaussian Variant of Hutch++)\n\n**Require:** Matrix-vector multiplication oracle for matrix $\\mA \\in \\mathbb{R}^{n \\times n}$. Number of queries, $m$.  \n**Ensure:** Approximation to $\\tr(\\mA)$.\n\n1.  Sample $\\mS \\in \\mathbb{R}^{n \\times \\frac{m+2}{4}}$ with i.i.d.\\ $\\mathcal{N}(0,1)$ entries and $\\mG \\in \\mathbb{R}^{n \\times \\frac{m-2}{2}}$ with i.i.d.\\ Rademacher entries.\n2.  Compute an orthonormal basis $\\mQ \\in \\mathbb{R}^{n \\times \\frac{m+2}{4}}$ for the span of $\\mA\\mS$ (e.g., via QR decomposition).\n3.  **Return** Gaussian-Hutch++$(\\mA)= \\tr(\\mQ^\\top \\mA \\mQ) + \\frac{2}{m-2}\\,\\tr\\!\\big(\\mG^\\top(\\mI-\\mQ\\mQ^\\top)\\mA(\\mI-\\mQ\\mQ^\\top)\\mG\\big)$.\n:::\n\n# Numerical Experiments {#sec-experiments}\n\nTo verify the theoretical improvements of Hutch++ over the standard Hutchinson estimator and to contrast the Gaussian and Rademacher variants, we implemented the original Hutchinson estimator along with @alg-hutchplusplus and @alg-hutchplusplus-gaussian in Python using NumPy. \n\n## Experimental Setup\n\n**Matrix Construction**\nWe empirically verified the theoretical bounds using a modestly large SPSD matrix with dimension $N=4000$. The goal was to measure performance on four spectral regimes that highlight the strengths and weaknesses of each estimator. Recall that an SPSD matrix $\\mA$ can be diagonalized as $\\mA = \\mQ \\mD \\mQ^\\top$ where $\\mD$ is a diagonal matrix of eigenvalues $\\lambda_1 \\geq \\lambda_2 \\geq \\ldots \\geq \\lambda_N \\geq 0$ and $\\mQ$ is an orthogonal matrix of eigenvectors. The same Discrete Cosine Transform (DCT) mixing matrix $\\mQ$ discussed in @sec-avron is applied as a unitary operation for the basis-oblivious construction of dense test matrices from diagonal eigenvalue matrices $\\mD$. A diagonal-heavy matrix with concentrated blocks along the diagonal is used to evaluate performance on structured sparse matrices.\n\n* **Slow Decay ($\\lambda_k \\propto k^{-1}$):** The slow decay matrix is more uniform with fewer \"heavy-hitters\"; the eigenbasis is randomized with DCT.\n* **Fast Decay ($\\lambda_k \\propto k^{-2}$):** The quadratic decay has concentrated spectral energy in the leading eigenvalues; the eigenbasis is randomized with DCT.\n* **Diagonal-Heavy:** A block diagonal matrix with correlated blocks to concentrate $\\|\\mA\\|_F$ in the diagonal elements, creating a favorable scenario for Rademacher vectors in Hutchinson. A sample matrix of this form is shown in @fig-diag-heavy.\n* **Spiked Identity:** An identity matrix with a low-rank signal added to create a few large eigenvalues. A sample matrix of this form is shown in @fig-diag-heavy.\n\n![Samples of random Spiked Identity and Diagonal-Heavy SPSD matrices used in experiments, showing concentrated blocks along the diagonal.](figs/test_matrices_small.png){#fig-diag-heavy}\n\n**Evaluation Metrics**\nFor each of these tasks, the Rademacher and Gaussian variants of Hutchinson and Hutch++ were run for a range of MVP budgets $m$. The true trace $\\tr(\\mA)$ was computed directly for error calculation, and the convergence behavior was recorded. The relative error $|\\tr(\\mA) - T|/\\tr(\\mA)$ is averaged over 50 trials, with the variance shown to $\\pm \\frac{1}{2}\\sigma$.\n\n## Code and Trials\n\n#### Algorithm Implementation\n\nStarting with Hutchinson's estimator, the implementation is straightforward as shown below. The multiple queries are modeled as a matrix-matrix product for efficiency where $\\mV$ is a matrix of $m$ random vectors as columns. Using the property that the trace can be expressed as a Frobenius inner product, we have:\n\n$$\n\\begin{align}\n    T_H &= \\frac{1}{m} \\sum_{j=1}^m \\vv_j^\\top \\mA \\vv_j = \\frac{1}{m} \\sum_{j=1}^m [\\mV^\\top \\mA \\mV]_{jj} \\\\\n    &= \\frac{1}{m} \\tr(\\mV^\\top \\mA \\mV) \\\\\n        &= \\frac{1}{m}\\langle \\mV, \\mA \\mV \\rangle_F  = \\frac{1}{m}\\sum_{i=1}^n \\sum_{j=1}^m V_{ij} Y_{ij} ,\n\\end{align}\n$$\nwhich is computed by summing the elementwise product of $\\mV$ and $\\mY = \\mA \\mV$.\n\n::: {#67cc966f .cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import dct, idct\nimport time\n\ndef hutchinson(A, num_queries, dist=\"rademacher\"):\n    n = A.shape[0]\n    if dist == \"rademacher\":\n        V = np.random.randint(0, 2, size=(n, num_queries)) * 2 - 1\n    elif dist == \"gaussian\":\n        V = np.random.randn(n, num_queries)\n\n    Y = A @ V\n    trace_est = np.sum(V * Y) / num_queries\n    return trace_est\n```\n:::\n\n\nThe Hutch++ implementation follows the steps outlined in @alg-hutchplusplus and @alg-hutchplusplus-gaussian. In this case we optimize the computation step by noting that the projection $(\\mI - \\mQ \\mQ^\\top)$ can be applied efficiently without explicitly forming the projection matrix. For the projection matrix $P = \\mI - \\mQ \\mQ^\\top$, we have that $P = P^\\top$ and $P^2 = P$. Thus for any matrix $\\mG$ the projected MVP can be computed as $\\tr(P \\mA P) = \\tr(\\mA P)$ and so using standard Hutchinson on the residual becomes\n$$\n    \\tr(P \\mA P) = \\tr(PA) \\approx \\langle \\mG, P\\mA \\mG \\rangle_F\n$$\n\n::: {#0ad9e9c5 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\ndef hutch_plus_plus(A, num_queries, dist=\"rademacher\"):\n    \"\"\"\n    Hutch++ with support for Rademacher or Gaussian sketching.\n\n    Args:\n        A (ndarray): The input matrix.\n        num_queries (int): Total matrix-vector product budget (m).\n        dist (str): 'rademacher' or 'gaussian'. Controls the distribution of the\n                    sketching matrix Omega and the query split ratio.\n    \"\"\"\n    n = A.shape[0]\n    m = num_queries\n\n    # 1. construct the sketching matrix based on distribution\n    if dist == \"rademacher\":\n        # Rademacher uses m/3 split\n        s_queries = max(2, int(m / 3))\n        S = np.random.randint(0, 2, size=(n, s_queries)) * 2 - 1\n    elif dist == \"gaussian\":\n        # Gaussian uses (m+2)/4 split\n        s_queries = max(2, int((m + 2) / 4))\n        S = np.random.randn(n, s_queries)\n    else:\n        raise ValueError(\"dist must be 'rademacher' or 'gaussian'\")\n        \n    # 2. Compute the orthonormal basis Q for the sketch AS via QR decomposition\n    Y = A @ S\n    Q, _ = np.linalg.qr(Y)\n\n    # 3. Compute combination of lowrank trace with the residual hutchinson\n    AQ = A @ Q\n    tr_low_rank = np.sum(Q * AQ) # Frobenius inner product for trace\n\n    # Remaining queries for residual Hutchinson\n    m_rem = m - 2 * s_queries\n    if m_rem <= 0:\n        return tr_low_rank\n\n    # Sample new Rademacher vectors for residual trace estimation\n    G = np.random.randint(0, 2, size=(n, m_rem)) * 2 - 1\n    AG = A @ G\n\n    AG_proj = AG - Q @ (Q.T @ AG)  # Project AG onto the orthogonal complement of Q\n\n    # Each column product corresponds to one sample of the residual trace\n    tr_res = np.sum(G* AG_proj) / m_rem\n\n    return tr_low_rank + tr_res\n```\n:::\n\n\nFor experimentation, a generalized construction method for PSD with different spectral profiles is implemented by sampling eigenvalues from a $1/n^k$ decay function and applying the discrete cosine transform for mixing. The diagonal-heavy and spiked identity matrices are constructed directly.\n\n::: {#5d114e96 .cell execution_count=3}\n``` {.python .cell-code}\ndef generate_dct_rotated_matrix(n, decay_power):\n    \"\"\"\n    Constructs A = Q D Q^T SPSD matrix with:\n    - D: Diagonal with eigenvalues decaying as 1/k^decay_power\n    \"\"\"\n    # 1. Eigenvalues (Diagonal D)\n    evals = 1.0 / np.arange(1, n + 1) ** decay_power\n    D = np.diag(evals)\n\n    # 2. Construct Q via Randomized DCT\n    I = np.eye(n)\n    Q_dct = dct(I, type=2, norm=\"ortho\", axis=0)\n    signs = np.random.choice([-1, 1], size=n)\n    Q = Q_dct * signs[:, np.newaxis]  # Broadcasting to multiply rows\n\n    # 3. Construct A = Q D Q^T\n    A = Q @ D @ Q.T\n\n    return A, np.sum(evals)\n\ndef generate_clustered_covariance(N, n_clusters=5, cross_talk=0.01):\n    \"\"\"\n    Generates a Block Diagonal-ish Matrix (Clustered Correlation).\n    - 'n_clusters' dense blocks along the diagonal.\n    - 'cross_talk' weak random correlation between blocks.\n    \"\"\"\n    block_size = N // n_clusters\n    remainder = N % n_clusters\n\n    # Start with noise background (weak cross-talk)\n    # Construct as B * B^T to ensure SPSD\n    B_noise = np.random.randn(N, max(10, N // 10)) * np.sqrt(cross_talk)\n    A = B_noise @ B_noise.T\n\n    # Add dense blocks to diagonal\n    current_idx = 0\n    for i in range(n_clusters):\n        size = block_size + (1 if i < remainder else 0)\n\n        # Create a random dense correlation matrix for this block\n        # Spectrum: Linear decay (standard random matrix)\n        X_block = np.random.randn(size, size)\n        C_block = X_block @ X_block.T\n\n        # Normalize block to have reasonable scale (e.g., max eigenvalue ~ 1)\n        C_block /= np.linalg.norm(C_block, 2)\n\n        # Add to the big matrix diagonal\n        A[current_idx : current_idx + size, current_idx : current_idx + size] += C_block\n        current_idx += size\n\n    return A, np.trace(A)\n\ndef generate_spiked_identity(N, rank=50, signal_strength=100.0):\n    \"\"\"\n    Generates a 'Spiked Identity' matrix: A = I + U S U^T.\n    - N: Size of the matrix.\n    - rank: Rank of the low-rank signal.\n    - signal_strength: Controls the magnitude of the spikes.\n    \n\n    \"\"\"\n    # 1. Identity (Noise floor)\n    A = np.eye(N)\n    \n    # 2. Add Low Rank Signal (Spikes)\n    # Random subspace U\n    U = np.random.randn(N, rank)\n    U, _ = np.linalg.qr(U)\n    \n    # Eigenvalues for the signal part (decaying)\n    evals_signal = np.linspace(signal_strength, signal_strength/10, rank)\n    \n    # Update A: A = I + U * diag(S) * U^T\n    A += U @ (np.diag(evals_signal) @ U.T)\n    \n    true_trace = N + np.sum(evals_signal)\n    return A, true_trace\n```\n:::\n\n\n## Results and Discussion\nThe results are presented below in @fig-trace-performance:\n\n::: {#cell-fig-trace-performance .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nimport time\n\n# --- Setup and Execution ---\nnp.random.seed(42)\nN, trials = 2000, 30 \nquery_counts = np.unique(np.geomspace(12, 1200, num=12, dtype=int))\n\n# Generate Matrices (Functions must be defined in a previous cell)\ndatasets = [\n    (\"Slow Decay ($1/k$)\", generate_dct_rotated_matrix(N, 1.0)),\n    (\"Fast Decay ($1/k^2$)\", generate_dct_rotated_matrix(N, 2.0)),\n    (\"Clustered Covariance\", generate_clustered_covariance(N, 15)),\n    (\"Spiked Identity ($I + LR$)\", generate_spiked_identity(N, 40, 50.0)),        \n]\n\nmethods = [\n    (\"Hutch (Rad)\",   lambda A, q: hutchinson(A, q, \"rademacher\"),      \"#1f77b4\", \"o-\"),\n    (\"Hutch (Gauss)\", lambda A, q: hutchinson(A, q, \"gaussian\"),        \"#ff7f0e\", \"s--\"),\n    (\"H++ (Rad)\",     lambda A, q: hutch_plus_plus(A, q, \"rademacher\"), \"#2ca02c\", \"^-\"),\n    (\"H++ (Gauss)\",   lambda A, q: hutch_plus_plus(A, q, \"gaussian\"),   \"#9467bd\", \"d-.\"),\n]\n\n# These variables are now in the global scope\ntiming_results = {label: np.zeros(len(query_counts)) for label, _, _, _ in methods}\n\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\naxes_flat = axes.flatten()\n\nfor ax, (name, (A, true_tr)) in zip(axes_flat, datasets):\n    for label, func, color, fmt in methods:\n        errors = np.zeros((len(query_counts), trials))\n        for i, q in enumerate(query_counts):\n            for t in range(trials):\n                t0 = time.perf_counter()\n                est = func(A, q)\n                timing_results[label][i] += (time.perf_counter() - t0)\n                errors[i, t] = np.abs(est - true_tr) / true_tr\n\n        mu = np.mean(errors, axis=1)\n        ax.loglog(query_counts, mu, fmt, label=label, color=color, lw=1.5)\n\n    ax.loglog(query_counts, 1.0/np.sqrt(query_counts), \"k:\", label=r\"$O(1/\\sqrt{m})$\", alpha=0.4)\n    ax.loglog(query_counts, 1.0/query_counts, \"k-.\", label=r\"$O(1/m)$\", alpha=0.4)\n    ax.set_title(name)\n    if name == datasets[0][0]: ax.legend(fontsize=\"small\")\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Comparison of Hutchinson and Hutch++ trace estimators on random generated SPSD matrices with decaying eigenvalues. Hutch++ achieves lower error for the same number of MVPs on concentrated spectra, confirming the theoretical analysis.](index_files/figure-html/fig-trace-performance-output-1.png){#fig-trace-performance}\n:::\n:::\n\n\n<!-- ![Comparison of Hutchinson and Hutch++ trace estimators on random generated SPSD matrices with decaying eigenvalues. Hutch++ achieves lower error for the same number of MVPs on concentrated spectra, confirming the theoretical analysis.](figs/convergence_full.png){#fig-hutch-vs-hutchpp} -->\n\n**Impact of Decay Rate**\nAs expected, the Hutch++ performance gain is most pronounced in a fast decay spectrum, where the low-rank approximation concentrates the MVP budget on the largest contributors to variance in the trace estimate. The difference is accentuated by the log-log scale where Hutch++ quickly attains several orders of magnitude lower error for the same number of MVPs. For slow decays and smaller numbers of queries, the advantage is less pronounced over the standard Hutchinson.\n\n**Rademacher vs Gaussian**\nInterestingly, the choice of random variable does not have a significant impact on performance, despite the theoretical bounds and methods to attain them being quite different. Rademacher only shows a clear advantage in the diagonal-heavy regime, where it is able to even outperform the Hutch++ methods. Note that the Gaussian variant of Hutch++ only uses Gaussian variables for the sketching matrix, while the residual estimation still uses Rademacher vectors.\n\n**Convergence Slope**\nIn all regimes, the performance follows the slope of the bounds quite closely, indicating that the theoretical analysis is tight. In the fast decay regime, Hutch++ outperforms the theoretical bounds, which make no assumptions on the rate of decay. Note that the error is compared against the number of queries; the inverse relationship is thus $O(1/m)$, giving a slope of -1 on the log-log plots, while Hutchinson has a slope of -0.5 as expected from the $O(1/\\sqrt{m})$ dependence. The slope of Hutch++ in fast decay is even steeper, showing the adaptive leveraging of the spectrum.\n\n**Wall Clock Time**\nThe focus of this work has been on the bounds and theoretical convergence for trace estimation. However, factorization steps such as the $QR$ decomposition and generation of random vectors add time to the overhead. To get a better sense of practical performance with time as a resource instead of MVPs, a wall clock time comparison is shown in @fig-time-comparison. The time taken scales linearly with the queries, indicating that the MVP query bounds are roughly equivalent to the time bounds, as claimed by @meyer2021HutchOptimalStochastic. \n\n::: {#cell-fig-time-comparison .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nplt.figure(figsize=(10, 6))\n# Normalization: total trials across all 4 datasets\nnormalization = 4 * 30 \n\n# Accessing global variables from the cell above\nfor label, _, color, fmt in methods:\n    plt.plot(query_counts, timing_results[label] / normalization, \n             fmt, label=label, color=color, lw=1.5)\n    \nplt.title(\"Average Wall-Clock Time per Estimator\")\nplt.xlabel(\"Number of Queries (m)\")\nplt.ylabel(\"Time (seconds)\")\nplt.grid(True, alpha=0.3)\nplt.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Wall clock time comparison of Hutchinson and Hutch++ estimators on fast decay SPSD matrix. While Hutch++ has overhead from factorization, it quickly outperforms Hutchinson in error for the same amount of time.](index_files/figure-html/fig-time-comparison-output-1.png){#fig-time-comparison}\n:::\n:::\n\n\n# Conclusion {#sec-conclusion}\n\n## Future Work and Applications\nOne impactful application for matrix-free implicit trace estimation with Hutch++ is in the training of continuous normalizing flows and diffusion models. Recent work by @liu2025optimal directly leverages the Hutch++ estimator to improve divergence-based likelihood estimation. The process of $QR$ decomposition is modified to share the same decomposition of $Q$ across multiple time steps of the integration, reducing the overhead cost of the method without sacrificing too much performance, as the top eigenbasis of the Jacobian does not change significantly over small time intervals of the normalizing flow. To this effect, the problem above can be seen as a dynamic trace estimation problem where the implicit matrices are strongly correlated. @woodruffOptimalQueryComplexities addresses this optimization, building upon the original Hutch++ framework to improve the query complexity while also proving new lower bounds for Hutchinson, resolving the open question of tightness for original Hutchinson in @meyer2021HutchOptimalStochastic.\n\n## Summary\nThis work presents a review of randomized algorithms for implicit trace estimation with a focus on SPSD matrices. The progression of analysis from variance in Hutchinson's original Rademacher estimator, to the Chernoff-style bounds of @avron2011RandomizedAlgorithmsEstimating, to the optimal Hutch++ algorithm of @meyer2021HutchOptimalStochastic with provable lower bounds and optimality is presented. The progression of authorship and style is notable, with each work contributing further to a broad understanding of optimal implicit trace estimation in many settings. Numerical experiments confirm the theory, showing that Hutch++ is both theoretically and practically superior to Hutchinson in all but the most diagonal-heavy cases. Finally, the application of Hutch++ to generative AI models such as continuous normalizing flows and diffusion models is discussed, demonstrating the relevance of these methods to modern machine learning and research in this area.\n\nThe technique of adaptive variance reduction by isolating the top contributors to variance and attributing more resources to them is a powerful idea that we may expect to have further applications in randomized numerical linear algebra and beyond. The first step to many problems is identifying the nature of the problem itself, which the low-rank approximation step of Hutch++ effectively does, providing a provably optimal method for implicit trace estimation.\n\n# Appendix\n\n### Stronger Bound for $T_{GM}$\n@avron2011RandomizedAlgorithmsEstimating do much better starting with the moment generating function (MGF) of the $\\chi^2$ distribution to derive a Chernoff-style bound. Taking $Z=m T_{GM} = \\sum_{i=1}^N \\lambda_i X_i$ where $X_i \\sim \\chi^2_m$.\n\n::: {#lem-chi-squared-mgf .lemma}\nLet $X \\sim \\chi^2_m$. Then the moment generating function of $X$ is\n$$\n    M_{X}(t) = (1 - 2t)^{-m/2}, \\quad t < \\frac{1}{2}. \n$$\n:::\n\n::: {#def-elem-symmetric .definition}\n## Elementary Symmetric Polynomial\nThe $s$-th elementary symmetric polynomial of variables $\\lambda_1, \\ldots, \\lambda_N$ is defined as\n$$\n    e_s(\\lambda_1, \\ldots, \\lambda_N) := \\sum_{S \\subseteq \\{\\lambda_1,\\ldots,\\lambda_N\\}, |S|=s} \\prod_{\\lambda \\in S} \\lambda.\n$$\n:::\n\n::: {#lem-elem-symmetric-bound .lemma}\n## Elementary symmetric polynomial bound\nLet $\\lambda_1,\\ldots,\\lambda_N \\ge 0$. Then for all $s \\ge 2$,\n$$\ne_s(\\lambda)\n\\le\n\\frac{1}{s!}\\left(\\sum_{i=1}^N \\lambda_i\\right)^s\n= \\frac{1}{s!}\\,\\tr(\\mA)^s.\n$$\n:::\n\n**Proof.**\nBy the definition, $e_s$ gives all products of $s$ distinct $\\lambda_i$'s, that is with multiplicity one. On the other hand, expanding $\\left(\\sum_{i=1}^N \\lambda_i\\right)^s$, gives each distinct multiplicity one term $s!$ times due to permutations being included in the expansion. In addition there are terms with multiplicities higher than one which are not in $e_s$. Thus we have\n$$\n\\left(\\sum_{i=1}^N \\lambda_i\\right)^s = s! \\cdot e_s(\\lambda_1, \\ldots, \\lambda_N) + \\text{(higher multiplicities)}\n$$\n$$\n \\geq s! \\cdot e_s(\\lambda_1, \\ldots, \\lambda_N) \\quad \\text{ since } \\lambda_i \\geq 0\n$$\n$$\ne_s(\\lambda_1, \\ldots, \\lambda_N)  \\leq \\frac{1}{s!}\\left(\\sum_{i=1}^N \\lambda_i\\right)^s \\quad \\square\n$$\n\nTo prove the tighter bound for $T_{GM}$, we derive the MGF for $Z$ using the independence of the $X_i$'s and the scaling property of MGFs.\n$$\n\\begin{align}\nM_{Z}(t) &= \\mathbb{E}\\left[e^{t Z}\\right] \\\\\n&= \\prod_{i=1}^N M_{X_i}(\\lambda_i t) \\\\\n&= \\prod_{i=1}^N (1 - 2 \\lambda_i t)^{-m/2}, \\quad t < \\frac{1}{2 \\max_i \\lambda_i}.\n\\end{align}\n$$\nThe next step is to take the expansion of the product and bound the terms, noting that $\\lambda_i \\geq 0$ for SPSD matrices. Using the definition of the elementary symmetric polynomials, we have\n$$\nM_{Z}(t) = \\left(1-2 t \\tr(\\mA) + \\sum_{s=2}^{N}(-2)^st^s e_s(\\lambda_1, \\ldots, \\lambda_N) \\right)^{-m/2}\n$$\nUsing @lem-elem-symmetric-bound to bound the elementary symmetric polynomials, we have\n$$\n    \\left|  \\sum_{s=2}^{N}(-2)^st^s e_s(\\lambda_1, \\ldots, \\lambda_N) \\right|  \\leq \\sum_{s=2}^{N} 2^s |t|^s \\frac{1}{s!} \\tr(\\mA)^s  \\le \\sum_{s=2}^{N} \\left(2 t \\tr(\\mA)\\right)^s\n$$\nSetting $t_0 = \\frac{\\epsilon}{4 \\tr(\\mA)(1+\\epsilon/2)}$ ensures that $t_0 < \\frac{1}{2 \\max_i \\lambda_i}$ and the MGF is valid. Recalling that for a geometric series $\\sum_{s=2}^N r^s \\leq \\sum_{s=2}^\\infty r^s = \\frac{r^2}{1-r}$ for $|r|<1$, then we have\n$$\n    \\left|  \\sum_{s=2}^{N}(-2)^{s}t_0^{s} e_s(\\lambda_1, \\ldots, \\lambda_N) \\right|  \\leq \\left(\\frac{\\epsilon}{2(1+\\epsilon/2)}\\right)^2 \\left(1 - \\frac{\\epsilon}{2(1+\\epsilon/2)}\\right)^{-1} = \\frac{\\epsilon^2}{4(1+\\epsilon/2)}\n$$\n\nThe proof is then completed using Markov's inequality on the MGF shown in brief form here:\n$$\n\\begin{align}\n    \\Pr\\left[ T_{GM} \\geq (1+\\epsilon) \\tr(\\mA) \\right] &= \\Pr\\left[ Z \\geq m(1+\\epsilon) \\tr(\\mA) \\right] \\\\\n    &= \\Pr\\left[ \\exp({t_0 Z}) \\geq \\exp({t_0 m(1+\\epsilon) \\tr(\\mA)}) \\right] \\\\\n    &\\leq M_{Z}(t_0)\\exp\\left({-t_0 m(1+\\epsilon) \\tr(\\mA)}\\right) \\\\\n    & \\leq \\exp\\left(-m\\epsilon^2/20\\right).\n\\end{align}\n$$\nThe full proof is given in @avron2011RandomizedAlgorithmsEstimating [Theorem 5.2]. The same result is applied to the lower tail, with a union bound over both failure $\\delta/2$ events giving the final result that for an $(\\epsilon, \\delta)$-approximation we require.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}